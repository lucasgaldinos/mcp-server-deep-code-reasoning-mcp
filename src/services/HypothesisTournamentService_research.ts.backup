/**
 * Research-Informed Hypothesis Tournament Service
 * 
 * Research Finding: "Competitive hypothesis tournament to find root causes. 
 * Multiple AI conversations test different theories in parallel, with 
 * evidence-based scoring and elimination rounds."
 * 
 * This implements one of our unique differentiators identified in the research:
 * competitive root cause analysis that doesn't exist in other tools.
 */

import { ApiManager } from '@services/ApiManager.js';
import { ClaudeCodeContext, AnalysisResult, Provider } from '@models/types.js';
import { ApiError } from '@errors/index.js';

export interface TournamentConfig {
  maxHypotheses: number;
  maxRounds: number;
  parallelSessions: number;
  eliminationThreshold: number;
  confidenceRequirement: number;
}

export interface TournamentHypothesis {
  id: string;
  hypothesis: string;
  evidence: Array<{
    type: 'code_analysis' | 'static_analysis' | 'verification';
    content: string;
    confidence: number;
    timestamp: number;
  }>;
  score: number;
  eliminated: boolean;
  provider: string;
  createdAt: number;
}

export interface TournamentRound {
  roundNumber: number;
  startTime: number;
  endTime?: number;
  hypothesesActive: number;
  hypothesesEliminated: string[];
  evidenceGathered: number;
  roundResults: {
    topScorer: string;
    avgScore: number;
    eliminationThreshold: number;
  };
}

export interface TournamentResult {
  tournamentId: string;
  winner: TournamentHypothesis;
  allHypotheses: TournamentHypothesis[];
  rounds: TournamentRound[];
  finalAnalysis: AnalysisResult;
  metadata: {
    totalDuration: number;
    hypothesesGenerated: number;
    evidenceGathered: number;
    roundsCompleted: number;
    providersUsed: string[];
    confidenceScore: number;
  };
}

/**
 * Research Pattern: Competitive analysis with evidence-based elimination
 */
export class HypothesisTournamentService {
  private apiManager: ApiManager;
  private activeTournaments: Map<string, any> = new Map();

  constructor(apiManager: ApiManager) {
    this.apiManager = apiManager;
  }

  /**
   * Run a competitive hypothesis tournament
   * Research Pattern: "Multiple AI conversations test different theories in parallel"
   */
  async runTournament(
    context: ClaudeCodeContext,
    issueDescription: string,
    config: Partial<TournamentConfig> = {}
  ): Promise<TournamentResult> {
    const tournamentId = this.generateTournamentId();
    const tournamentConfig: TournamentConfig = {
      maxHypotheses: 6,
      maxRounds: 3,
      parallelSessions: 4,
      eliminationThreshold: 0.6,
      confidenceRequirement: 0.75,
      ...config
    };

    const tournament = {
      id: tournamentId,
      context,
      issue: issueDescription,
      config: tournamentConfig,
      hypotheses: new Map<string, TournamentHypothesis>(),
      rounds: [] as TournamentRound[],
      startTime: Date.now(),
      currentRound: 0
    };

    this.activeTournaments.set(tournamentId, tournament);

    try {
      // Phase 1: Generate initial hypotheses using multiple providers
      await this.generateInitialHypotheses(tournament);

      // Phase 2: Run competitive rounds with evidence gathering
      while (tournament.currentRound < tournamentConfig.maxRounds) {
        const activeHypotheses = Array.from(tournament.hypotheses.values())
          .filter(h => !h.eliminated);

        if (activeHypotheses.length <= 1) break;

        await this.runTournamentRound(tournament);
        tournament.currentRound++;
      }

      // Phase 3: Deep verification of winning hypothesis
      const winner = await this.determineWinner(tournament);
      const finalAnalysis = await this.generateFinalAnalysis(tournament, winner);

      const result = this.buildTournamentResult(tournament, winner, finalAnalysis);
      this.activeTournaments.delete(tournamentId);

      return result;

    } catch (error) {
      this.activeTournaments.delete(tournamentId);
      throw new ApiError(`Tournament failed: ${error.message}`, 'TOURNAMENT_ERROR');
    }
  }

  /**
   * Research Pattern: Multi-provider hypothesis generation for diversity
   */
  private async generateInitialHypotheses(tournament: any): Promise<void> {
    const { context, issue, config } = tournament;
    
    // Create analysis contexts for hypothesis generation
    const hypothesisContext = {
      ...context,
      stuckPoints: [...context.stuckPoints, `Generate hypotheses for: ${issue}`]
    };

    const hypothesesPerProvider = Math.ceil(config.maxHypotheses / 2); // Gemini and OpenAI

    try {
      // Generate hypotheses using Gemini
      const geminiResult = await this.apiManager.analyzeWithProvider(
        'gemini',
        hypothesisContext,
        'hypothesis_generation'
      );

      // Generate hypotheses using OpenAI
      const openaiResult = await this.apiManager.analyzeWithProvider(
        'openai', 
        hypothesisContext,
        'hypothesis_generation'
      );

      const allHypotheses = [
        ...this.parseHypothesesFromResponse(geminiResult.result.analysis, 'gemini'),
        ...this.parseHypothesesFromResponse(openaiResult.result.analysis, 'openai')
      ];
      
      // Create tournament hypotheses
      allHypotheses.slice(0, config.maxHypotheses).forEach((hypothesis, index) => {
        const hypothesisId = `hyp_${index + 1}_${Date.now()}`;
        const tournamentHypothesis: TournamentHypothesis = {
          id: hypothesisId,
          hypothesis: hypothesis.text,
          evidence: [],
          score: 0,
          eliminated: false,
          provider: hypothesis.provider,
          createdAt: Date.now()
        };

        tournament.hypotheses.set(hypothesisId, tournamentHypothesis);
      });

    } catch (error) {
      throw new ApiError(`Failed to generate hypotheses: ${error instanceof Error ? error.message : 'Unknown error'}`, 'HYPOTHESIS_GENERATION_ERROR');
    }
  }

  /**
   * Research Pattern: Evidence-based scoring and elimination rounds
   */
  private async runTournamentRound(tournament: any): Promise<void> {
    const roundNumber = tournament.currentRound + 1;
    const activeHypotheses = Array.from(tournament.hypotheses.values())
      .filter(h => !h.eliminated);

    const round: TournamentRound = {
      roundNumber,
      startTime: Date.now(),
      hypothesesActive: activeHypotheses.length,
      hypothesesEliminated: [],
      evidenceGathered: 0,
      roundResults: {
        topScorer: '',
        avgScore: 0,
        eliminationThreshold: 0
      }
    };

    // Gather evidence for each active hypothesis in parallel
    const evidencePromises = activeHypotheses.map(hypothesis => 
      this.gatherEvidenceForHypothesis(tournament, hypothesis)
    );

    await Promise.allSettled(evidencePromises);

    // Score hypotheses based on evidence quality and quantity
    this.scoreHypotheses(tournament, activeHypotheses);

    // Eliminate bottom performers
    const eliminationResults = this.eliminateWeakHypotheses(
      tournament, 
      activeHypotheses, 
      tournament.config.eliminationThreshold
    );

    // Update round results
    round.endTime = Date.now();
    round.hypothesesEliminated = eliminationResults.eliminated;
    round.evidenceGathered = eliminationResults.evidenceCount;
    round.roundResults = eliminationResults.roundResults;

    tournament.rounds.push(round);
  }

  /**
   * Research Pattern: Multi-source evidence gathering
   */
  private async gatherEvidenceForHypothesis(
    tournament: any, 
    hypothesis: TournamentHypothesis
  ): Promise<void> {
    const evidencePrompt = this.buildEvidenceGatheringPrompt(
      tournament.context,
      hypothesis.hypothesis
    );

    try {
      // Code analysis evidence
      const codeAnalysis = await this.apiManager.analyzeWithProvider(
        Provider.GEMINI,
        evidencePrompt,
        { maxTokens: 3072, temperature: 0.2 }
      );

      hypothesis.evidence.push({
        type: 'code_analysis',
        content: codeAnalysis.result,
        confidence: codeAnalysis.confidence,
        timestamp: Date.now()
      });

    } catch (error) {
      console.warn(`Failed to gather evidence for hypothesis ${hypothesis.id}:`, error.message);
    }
  }

  /**
   * Research Pattern: Evidence-based scoring algorithm
   */
  private scoreHypotheses(tournament: any, hypotheses: TournamentHypothesis[]): void {
    hypotheses.forEach(hypothesis => {
      let score = 0;
      let totalWeight = 0;

      hypothesis.evidence.forEach(evidence => {
        const weight = this.getEvidenceWeight(evidence.type);
        score += evidence.confidence * weight;
        totalWeight += weight;
      });

      // Normalize score
      hypothesis.score = totalWeight > 0 ? score / totalWeight : 0;

      // Boost score for specificity and detail
      const specificity = this.calculateSpecificity(hypothesis.hypothesis);
      hypothesis.score *= (1 + specificity * 0.2);

      // Penalty for lack of evidence
      if (hypothesis.evidence.length === 0) {
        hypothesis.score *= 0.1;
      }
    });
  }

  /**
   * Research Pattern: Bottom-half elimination strategy
   */
  private eliminateWeakHypotheses(
    tournament: any, 
    hypotheses: TournamentHypothesis[], 
    thresholdFactor: number
  ): any {
    const scores = hypotheses.map(h => h.score).sort((a, b) => b - a);
    const medianScore = scores[Math.floor(scores.length / 2)];
    const eliminationThreshold = medianScore * thresholdFactor;

    const eliminated: string[] = [];
    let evidenceCount = 0;

    hypotheses.forEach(hypothesis => {
      if (hypothesis.score < eliminationThreshold && hypotheses.length > 2) {
        hypothesis.eliminated = true;
        eliminated.push(hypothesis.id);
      }
      evidenceCount += hypothesis.evidence.length;
    });

    const remainingHypotheses = hypotheses.filter(h => !h.eliminated);
    const topScorer = remainingHypotheses.reduce((top, current) => 
      current.score > top.score ? current : top
    );

    return {
      eliminated,
      evidenceCount,
      roundResults: {
        topScorer: topScorer.id,
        avgScore: scores.reduce((sum, score) => sum + score, 0) / scores.length,
        eliminationThreshold
      }
    };
  }

  /**
   * Determine tournament winner and run final verification
   */
  private async determineWinner(tournament: any): Promise<TournamentHypothesis> {
    const activeHypotheses = Array.from(tournament.hypotheses.values())
      .filter(h => !h.eliminated)
      .sort((a, b) => b.score - a.score);

    if (activeHypotheses.length === 0) {
      throw new ApiError('No hypotheses survived tournament', 'NO_WINNER');
    }

    const winner = activeHypotheses[0];

    // Final verification using deep reasoning
    try {
      const verificationPrompt = this.buildVerificationPrompt(tournament.context, winner);
      const verification = await this.apiManager.analyzeWithProvider(
        Provider.GEMINI,
        verificationPrompt,
        { maxTokens: 4096, temperature: 0.1 }
      );

      winner.evidence.push({
        type: 'verification',
        content: verification.result,
        confidence: verification.confidence,
        timestamp: Date.now()
      });

    } catch (error) {
      console.warn('Final verification failed:', error.message);
    }

    return winner;
  }

  /**
   * Generate comprehensive final analysis
   */
  private async generateFinalAnalysis(
    tournament: any, 
    winner: TournamentHypothesis
  ): Promise<AnalysisResult> {
    const analysisPrompt = this.buildFinalAnalysisPrompt(tournament, winner);

    const finalAnalysis = await this.apiManager.analyzeWithProvider(
      Provider.GEMINI,
      analysisPrompt,
      { maxTokens: 8192, temperature: 0.05 }
    );

    return {
      analysis: finalAnalysis.result,
      confidence: this.calculateFinalConfidence(winner),
      reasoning: this.buildTournamentReasoningChain(tournament, winner),
      recommendations: this.extractRecommendations(finalAnalysis.result),
      metadata: {
        tournamentId: tournament.id,
        winningHypothesis: winner.hypothesis,
        competitorsEliminated: Array.from(tournament.hypotheses.values())
          .filter(h => h.eliminated).length,
        evidenceGathered: winner.evidence.length,
        roundsCompleted: tournament.rounds.length,
        provider: 'hypothesis_tournament'
      }
    };
  }

  // Utility and helper methods
  private generateTournamentId(): string {
    return `tournament_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private buildHypothesisGenerationPrompt(
    context: ClaudeCodeContext, 
    issue: string, 
    providerIndex: number, 
    count: number
  ): string {
    const approaches = [
      'Focus on execution paths and data flow analysis',
      'Emphasize architectural patterns and design issues'
    ];

    return `# Hypothesis Generation - Round ${providerIndex + 1}

## Context
**Files:** ${context.focusArea.files.join(', ')}
**Issue:** ${issue}
**Approach:** ${approaches[providerIndex] || approaches[0]}

## Task
Generate ${count} distinct, testable hypotheses about the root cause. Each should be:
1. Specific and actionable
2. Based on concrete code analysis
3. Different from typical obvious answers
4. Verifiable through investigation

Focus on your assigned approach while considering cross-cutting concerns.

Format: Return as numbered list with brief justification for each.`;
  }

  private buildEvidenceGatheringPrompt(context: ClaudeCodeContext, hypothesis: string): string {
    return `# Evidence Gathering

## Hypothesis to Investigate
${hypothesis}

## Code Context
**Files:** ${context.focusArea.files.join(', ')}
**Entry Points:** ${context.focusArea.entryPoints?.map(ep => `${ep.file}:${ep.line}`).join(', ') || 'None'}

## Task
Gather concrete evidence that supports or refutes this hypothesis. Look for:
1. Specific code patterns and implementations
2. Data flow and execution paths
3. Error conditions and edge cases
4. Performance characteristics
5. Dependencies and interactions

Provide specific evidence with confidence ratings (0.0-1.0).`;
  }

  private parseHypothesesFromResponse(response: string, provider: string): any[] {
    const hypotheses: any[] = [];
    const lines = response.split('\n');

    for (const line of lines) {
      const match = line.match(/^\d+\.\s*(.+)/);
      if (match && match[1].length > 20) {
        hypotheses.push({
          text: match[1].trim(),
          provider
        });
      }
    }

    return hypotheses;
  }

  private getEvidenceWeight(type: string): number {
    const weights = {
      'code_analysis': 1.0,
      'static_analysis': 0.9,
      'verification': 1.2
    };
    return weights[type as keyof typeof weights] || 0.5;
  }

  private calculateSpecificity(hypothesis: string): number {
    const specificityKeywords = [
      'function', 'method', 'class', 'variable', 'line', 'file'
    ];
    
    const matches = specificityKeywords.filter(keyword => 
      hypothesis.toLowerCase().includes(keyword)
    ).length;
    
    return Math.min(1.0, matches * 0.2);
  }

  private buildVerificationPrompt(context: ClaudeCodeContext, winner: TournamentHypothesis): string {
    return `# Final Hypothesis Verification

## Winning Hypothesis
${winner.hypothesis}

## Evidence Summary
${winner.evidence.map(e => `- **${e.type.toUpperCase()}** (${e.confidence.toFixed(2)}): ${e.content.substring(0, 200)}...`).join('\n')}

## Context
${this.formatContextForPrompt(context)}

## Task
Conduct rigorous final verification:
1. Validate evidence quality and relevance
2. Check for logical consistency
3. Look for counter-evidence
4. Assess implementation feasibility
5. Rate overall confidence (0.0-1.0)

Provide definitive verification assessment.`;
  }

  private buildFinalAnalysisPrompt(tournament: any, winner: TournamentHypothesis): string {
    const allHypotheses = Array.from(tournament.hypotheses.values());
    const eliminated = allHypotheses.filter(h => h.eliminated);

    return `# Tournament Analysis - Final Report

## Tournament Summary
- **Issue:** ${tournament.issue}
- **Hypotheses Generated:** ${allHypotheses.length}
- **Rounds Completed:** ${tournament.rounds.length}
- **Hypotheses Eliminated:** ${eliminated.length}

## Winning Hypothesis
**Hypothesis:** ${winner.hypothesis}
**Score:** ${winner.score.toFixed(3)}
**Provider:** ${winner.provider}
**Evidence Count:** ${winner.evidence.length}

## Task
Synthesize the tournament results into authoritative final analysis:
1. Explain why the winning hypothesis emerged victorious
2. Summarize key evidence that supports the conclusion
3. Address any remaining uncertainties
4. Provide specific, actionable recommendations
5. Suggest verification steps

Be definitive where evidence is strong, cautious where weak.`;
  }

  private buildTournamentResult(
    tournament: any, 
    winner: TournamentHypothesis, 
    finalAnalysis: AnalysisResult
  ): TournamentResult {
    const allHypotheses = Array.from(tournament.hypotheses.values());
    const providersUsed = [...new Set(allHypotheses.map(h => h.provider))];

    return {
      tournamentId: tournament.id,
      winner,
      allHypotheses,
      rounds: tournament.rounds,
      finalAnalysis,
      metadata: {
        totalDuration: Date.now() - tournament.startTime,
        hypothesesGenerated: allHypotheses.length,
        evidenceGathered: allHypotheses.reduce((sum, h) => sum + h.evidence.length, 0),
        roundsCompleted: tournament.rounds.length,
        providersUsed,
        confidenceScore: this.calculateFinalConfidence(winner)
      }
    };
  }

  private formatContextForPrompt(context: ClaudeCodeContext): string {
    return `**Files:** ${context.focusArea.files.join(', ')}
**Entry Points:** ${context.focusArea.entryPoints?.map(ep => `${ep.file}:${ep.line}`).join(', ') || 'None'}
**Attempted Approaches:** ${context.attemptedApproaches.join(', ')}
**Stuck Points:** ${context.stuckPoints.join(', ')}`;
  }

  private calculateFinalConfidence(winner: TournamentHypothesis): number {
    if (winner.evidence.length === 0) return 0.1;

    const avgEvidenceConfidence = winner.evidence.reduce((sum, e) => sum + e.confidence, 0) / winner.evidence.length;
    const scoreBonus = Math.min(0.2, winner.score * 0.2);
    const evidenceBonus = Math.min(0.15, winner.evidence.length * 0.03);

    return Math.min(0.95, avgEvidenceConfidence + scoreBonus + evidenceBonus);
  }

  private buildTournamentReasoningChain(tournament: any, winner: TournamentHypothesis): string {
    return `Tournament Reasoning Chain:
1. Generated ${Array.from(tournament.hypotheses.values()).length} competing hypotheses
2. Ran ${tournament.rounds.length} elimination rounds with evidence gathering
3. Eliminated ${Array.from(tournament.hypotheses.values()).filter(h => h.eliminated).length} weaker hypotheses
4. Winner "${winner.hypothesis}" scored ${winner.score.toFixed(3)} with ${winner.evidence.length} evidence pieces
5. Final verification achieved ${this.calculateFinalConfidence(winner).toFixed(2)} confidence
6. Tournament duration: ${Math.round((Date.now() - tournament.startTime) / 1000)} seconds`;
  }

  private extractRecommendations(analysis: string): string[] {
    const recommendations = [];
    const lines = analysis.split('\n');
    
    for (const line of lines) {
      const trimmed = line.trim();
      if (trimmed.toLowerCase().includes('recommend') || 
          trimmed.toLowerCase().includes('should') || 
          trimmed.toLowerCase().includes('action') ||
          trimmed.match(/^\d+\./)) {
        recommendations.push(trimmed);
      }
    }
    
    return recommendations.length > 0 ? recommendations.slice(0, 5) : [
      'Implement the winning hypothesis solution',
      'Verify findings through targeted testing',
      'Monitor the fix to ensure effectiveness'
    ];
  }
}
