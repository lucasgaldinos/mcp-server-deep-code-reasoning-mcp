/**
 * @fileoverview Quick Analysis Strategy Implementation
 *
 * This module implements a fast analysis strategy optimized for speed and
 * immediate results. This strategy is designed for scenarios where rapid
 * feedback is more important than comprehensive analysis depth.
 *
 * @author Deep Code Reasoning MCP Server
 * @version 1.0.0
 * @since 2025-01-09
 */

import {
  IReasoningStrategy,
  IAnalysisContext,
  IAnalysisResult,
  IStrategyCapabilities,
  BaseReasoningStrategy,
  AnalysisType,
} from './ReasoningStrategy.js';
import { createLogger } from '@utils/StructuredLogger.js';
import { EnvironmentValidator } from '@utils/EnvironmentValidator.js';
import { GoogleGenerativeAI } from '@google/generative-ai';

/**
 * Quick Analysis Strategy
 *
 * Provides fast code analysis using focused prompts and reduced context.
 * Best suited for rapid feedback and quick issue identification.
 */
export class QuickAnalysisStrategy extends BaseReasoningStrategy {
  readonly name = 'QuickAnalysisStrategy';
  readonly version = '1.0.0';
  readonly capabilities: IStrategyCapabilities = {
    name: this.name,
    description: 'Fast analysis strategy optimized for speed and immediate results',
    supportedAnalysisTypes: [
      AnalysisType.QUICK_SCAN,
      AnalysisType.CODE_QUALITY,
      AnalysisType.DOCUMENTATION_ANALYSIS,
    ],
    minimumTimeConstraint: 5000, // 5 seconds minimum
    maximumFileCount: 10,
    memoryRequirement: 50 * 1024 * 1024, // 50MB
    requiresExternalServices: true,
    strengthAreas: [
      'Rapid issue identification',
      'Quick syntax and style checking',
      'Basic performance warnings',
      'Simple refactoring suggestions',
      'Documentation gaps detection',
    ],
    limitations: [
      'Limited analysis depth',
      'No cross-system analysis',
      'Basic architecture assessment only',
      'May miss complex patterns',
    ],
  };

  private readonly logger = createLogger('QuickAnalysisStrategy');
  private genAI?: GoogleGenerativeAI;
  private model?: ReturnType<GoogleGenerativeAI['getGenerativeModel']>;

  constructor() {
    super();
  }

  async analyze(context: IAnalysisContext): Promise<IAnalysisResult> {
    const startTime = Date.now();
    const startMemory = process.memoryUsage().heapUsed;

    try {
      this.logger.info('Starting quick analysis', {
        files: context.files.length,
        query: context.query.substring(0, 50),
        correlationId: context.correlationId,
      });

      // Prepare analysis context
      await this.prepare?.(context);

      // Validate context suitability
      const suitability = await this.canHandle(context);
      if (suitability < 0.4) {
        return this.createResult(
          false,
          'Context not suitable for quick analysis strategy',
          0.1,
          Date.now() - startTime,
          process.memoryUsage().heapUsed - startMemory,
        );
      }

      // Perform quick analysis
      const analysis = await this.performQuickAnalysis(context);

      const executionTime = Date.now() - startTime;
      const memoryUsed = process.memoryUsage().heapUsed - startMemory;

      this.logger.info('Quick analysis completed', {
        executionTime,
        memoryUsed,
        analysisLength: analysis.length,
        correlationId: context.correlationId,
      });

      return this.createResult(
        true,
        analysis,
        0.7, // Good confidence for quick analysis
        executionTime,
        memoryUsed,
        {
          analysisType: 'quick',
          fileCount: context.files.length,
          strategy: this.name,
        },
      );

    } catch (error) {
      const executionTime = Date.now() - startTime;
      const memoryUsed = process.memoryUsage().heapUsed - startMemory;

      this.logger.error('Quick analysis failed', {
        error: error instanceof Error ? error.message : String(error),
        executionTime,
        correlationId: context.correlationId,
      }, error instanceof Error ? error : undefined);

      return this.createResult(
        false,
        `Quick analysis failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
        0.1,
        executionTime,
        memoryUsed,
      );
    } finally {
      await this.cleanup?.();
    }
  }

  async canHandle(context: IAnalysisContext): Promise<number> {
    // Check file count constraints - prefer smaller sets
    if (context.files.length > this.capabilities.maximumFileCount!) {
      return 0.1; // Too many files for quick analysis
    }

    // Prioritize when speed is important
    if (context.prioritizeSpeed) {
      return 0.9; // High suitability for speed
    }

    // Check time constraints - good for short time limits
    if (context.timeConstraint && context.timeConstraint < 30000) {
      return 0.8; // Good for tight time constraints
    }

    // Check for supported analysis types
    const supportsAnalysis = this.capabilities.supportedAnalysisTypes.some(type =>
      context.query.toLowerCase().includes(type.replace('_', ' ')),
    );

    if (supportsAnalysis) {
      return 0.8; // High suitability
    }

    // Default moderate suitability for quick scans
    return 0.6;
  }

  private async performQuickAnalysis(context: IAnalysisContext): Promise<string> {
    if (!this.model) {
      throw new Error('Gemini model not available for quick analysis');
    }

    // Read and prepare file contents (limited for speed)
    const fileContents = await this.readFiles(context.files.slice(0, 5)); // Limit to 5 files

    // Construct focused analysis prompt
    const prompt = this.buildQuickAnalysisPrompt(context.query, fileContents, context);

    // Use Gemini model with speed-optimized settings
    const result = await this.model.generateContent(prompt);
    const response = await result.response;
    const text = response.text();

    return this.enhanceAnalysisResult(text || 'Quick analysis completed', context);
  }

  private buildQuickAnalysisPrompt(query: string, fileContents: Map<string, string>, context: IAnalysisContext): string {
    const fileList = Array.from(fileContents.keys()).join(', ');

    let prompt = `# Quick Code Analysis Request

## Analysis Query
${query}

## Analysis Context
- Files to analyze: ${fileList}
- Total files: ${fileContents.size}
- Analysis type: Quick scan for immediate insights
- Focus: Speed and actionable findings

## Instructions
Perform a FOCUSED, RAPID analysis of the provided code with emphasis on:
1. **Immediate Issues**: Critical errors, syntax problems, obvious bugs
2. **Quick Wins**: Simple improvements and fixes
3. **Code Quality**: Basic style and maintainability issues
4. **Performance**: Obvious performance problems
5. **Security**: Clear security vulnerabilities

IMPORTANT: Keep analysis concise and actionable. Focus on the most impactful findings.

## Code Files (Limited for Speed)
`;

    // Add file contents with clear separation (truncate large files)
    for (const [filePath, content] of fileContents) {
      const truncatedContent = content.length > 2000 ?
        content.substring(0, 2000) + '\n... (file truncated for quick analysis)' :
        content;
      prompt += `\n### File: ${filePath}\n\`\`\`\n${truncatedContent}\n\`\`\`\n`;
    }

    prompt += `\n## Expected Output Format
Provide a CONCISE analysis with:
- **ðŸš¨ Critical Issues**: Immediate problems requiring attention
- **âš¡ Quick Fixes**: Simple improvements with high impact
- **ðŸ’¡ Recommendations**: Top 3 actionable suggestions
- **ðŸ“Š Summary**: One-line overall assessment

Keep responses brief and focused on actionable items.`;

    return prompt;
  }

  private async readFiles(filePaths: string[]): Promise<Map<string, string>> {
    const fileContents = new Map<string, string>();

    // Use existing file reading utilities from the system
    // Limit processing for speed
    for (const filePath of filePaths.slice(0, 5)) {
      try {
        // Placeholder for actual file reading
        // In real implementation, this would use SecureCodeReader with size limits
        const content = `// File content would be read here: ${filePath}`;
        fileContents.set(filePath, content);
      } catch (error) {
        this.logger.warn('Failed to read file', { filePath, error });
        // Skip failed files in quick analysis
      }
    }

    return fileContents;
  }

  private enhanceAnalysisResult(analysis: string, context: IAnalysisContext): string {
    // Add minimal metadata for quick results
    const timestamp = new Date().toISOString();
    const enhancement = `
# âš¡ Quick Analysis Report
*Generated: ${timestamp}*
*Strategy: ${this.name} v${this.version}*
*Files Analyzed: ${context.files.length}*

---

${analysis}

---

## Analysis Metadata
- **Strategy**: Quick Analysis (Speed Optimized)
- **Scope**: ${context.files.length} files (limited for speed)
- **Focus**: Immediate actionable insights
- **Correlation ID**: ${context.correlationId || 'N/A'}

*For comprehensive analysis, consider using the Deep Analysis Strategy.*
`;

    return enhancement;
  }

  async prepare(context: IAnalysisContext): Promise<void> {
    this.logger.debug('Preparing quick analysis strategy', {
      correlationId: context.correlationId,
    });

    // Initialize Gemini service with speed-optimized settings
    if (!this.genAI) {
      const config = EnvironmentValidator.getValidatedConfig();
      this.genAI = new GoogleGenerativeAI(config.geminiApiKey);
      this.model = this.genAI.getGenerativeModel({
        model: config.geminiModel,
        generationConfig: {
          temperature: 0.1, // Lower temperature for faster, more deterministic results
          topK: 1,
          topP: 0.8, // Slightly lower for more focused responses
          maxOutputTokens: 2048, // Smaller output for speed
        },
      }, {
        apiVersion: config.geminiApiVersion,
      });
    }

    // Set up context for logging
    if (context.correlationId) {
      this.logger.setCorrelationId(context.correlationId);
    }
  }

  async cleanup(): Promise<void> {
    this.logger.debug('Cleaning up quick analysis strategy');
    // Minimal cleanup for speed
  }

  async estimateResources(context: IAnalysisContext): Promise<{
    estimatedTime: number;
    estimatedMemory: number;
    confidence: number;
  }> {
    // Quick analysis has predictable, low resource requirements
    const fileCount = Math.min(context.files.length, 5); // Limit processing

    return {
      estimatedTime: Math.max(2000 + (fileCount * 1000), 1000), // 2-7 seconds typical
      estimatedMemory: 25 * 1024 * 1024, // 25MB typical
      confidence: 0.9, // High confidence in quick analysis estimates
    };
  }
}
